Youâ€™re absolutely right ğŸ‘ â€” what I gave you was structured text, but not visually enhanced Markdown.

Now Iâ€™ll give you a properly formatted GitHub-friendly Markdown version with:

Clear section hierarchy

Tables

Code blocks

Clean spacing

Visual structure

Professional tone

Architect-level but concise

No flashy AI-looking content.

You can copy this directly into README.md.

Airline Seat Reservation System
Overview

This project implements a simplified Airline Seat Reservation System designed using production-oriented architectural principles.

The system demonstrates:

Modular monolithic architecture

Event-driven internal communication

Concurrency-safe seat booking

In-memory caching

Docker-based deployment

CI pipeline with automated image publishing

Architecture

The backend follows a modular monolith design with clearly separated domain modules:

Module	Responsibility
Inventory	Seat availability & locking
Booking	Booking lifecycle orchestration
Payment	Asynchronous payment processing

Components communicate using Spring Application Events, enabling event-driven behavior without external message brokers.

Architectural Characteristics

Synchronous seat locking

Asynchronous payment confirmation

Optimistic locking for concurrency control

Transactional consistency

REST-based API design

Container-first deployment

Booking Flow
Client
   â”‚
   â–¼
Seat Lock (synchronous)
   â”‚
   â–¼
Booking Created (PENDING_PAYMENT)
   â”‚
   â–¼
Payment Event Triggered (async)
   â”‚
   â”œâ”€â”€ Success â†’ CONFIRMED + Seat BOOKED
   â””â”€â”€ Failure â†’ FAILED + Seat Released


This guarantees seat consistency under concurrent booking attempts.

Concurrency Strategy

Seat entity includes:

@Version
private Long version;


If two users attempt to book the same seat:

First transaction commits successfully

Second transaction fails due to version conflict

Seat remains consistent

This prevents double-booking.

Caching Strategy

Flight search results are cached using Caffeine (in-memory cache).

Setting	Value
TTL	10 minutes
Max Entries	100
Eviction	LRU

This simulates production-style read optimization without external dependencies.

Technology Stack
Backend

Java 17

Spring Boot 3

Spring Data JPA

Hibernate

H2 Database

Caffeine Cache

JUnit 5 / Mockito

DevOps

Docker (multi-stage build)

Docker Compose

GitHub Actions

DockerHub

Frontend (separate module)

Flutter

Project Structure
puresoft_assignment/
â”‚
â”œâ”€â”€ .github/workflows/      # CI pipeline
â”œâ”€â”€ airline/                # Spring Boot backend
â”‚   â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ pom.xml
â”‚   â””â”€â”€ Dockerfile
â”‚
â”œâ”€â”€ airline_app/            # Flutter client
â””â”€â”€ docker-compose.yml

Running the Backend

From the airline directory:

mvn clean install
mvn spring-boot:run


H2 console:

http://localhost:8080/h2-console

Docker Deployment

Build image:

docker build -t nooruskhan/airline_backend:latest .


Run container:

docker run -p 8080:8080 nooruskhan/airline_backend:latest

CI Pipeline

The GitHub Actions workflow performs:

Maven build & test

Docker image build

DockerHub push

Published image:

nooruskhan/airline_backend:latest

Design Decisions

Modular monolith chosen over microservices for scope clarity

Internal event-driven design for loose coupling

Optimistic locking for concurrency correctness

In-memory cache to simulate production read scaling

Containerized from inception
